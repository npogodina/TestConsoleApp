// Autofac is an IoC (Invertion of Control) container for Microsoft.NET.
// It manages the dependencies between classes so that applications stay easy to change as they grow in size and complexity.
using Autofac;

using MoreLinq;
using NUnit.Framework;

namespace Singleton;

// Singleton = controversial design pattern
// Component that is instatiated only once.

// Motivation:
// 1) For some components it makes sense to have only one in the system
// - database repository
// - object factory
// 2) Constructor call is expensive. We want to:
// - do it once
// - provide everyone with the same instance
// 3) Want to prevent anyone from creating additinal copies
// 4) Need to take care of lazy instantiation and threat safety

// Pattern: create a non-singleton class and use it as singleton via Dependency Injection

public interface IDatabase
{
    int GetPopulation(string city);
}

public class SingletonDatabase : IDatabase
{
    private Dictionary<string, int> capitals;

    private SingletonDatabase()
    {
        Console.WriteLine("Initializing database...");
        capitals = File.ReadAllLines("Capitals.txt")
            .Batch(2)
            .ToDictionary(
                list => list.ElementAt(0).Trim(),
                list => int.Parse(list.ElementAt(1)));
    }

    // Use lazy initialization to defer the creation of a large or resource-intensive object,
    // or the execution of a resource-intensive task,
    // particularly when such creation or execution might not occur during the lifetime of the program.
    // https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1?redirectedfrom=MSDN&view=net-7.0
    private static Lazy<SingletonDatabase> instance = new Lazy<SingletonDatabase>(() => new SingletonDatabase());

    public static SingletonDatabase Instance => instance.Value;

    public int GetPopulation(string city)
    {
        return capitals[city];
    }
}

public class OrdinaryDatabase : IDatabase
{
    private Dictionary<string, int> capitals;

    public OrdinaryDatabase()
    {
        Console.WriteLine("Initializing database...");
        capitals = File.ReadAllLines("Capitals.txt")
            .Batch(2)
            .ToDictionary(
                list => list.ElementAt(0).Trim(),
                list => int.Parse(list.ElementAt(1)));
    }

    public int GetPopulation(string city)
    {
        return capitals[city];
    }
}

public class DummyDatabase : IDatabase
{
    public int GetPopulation(string city)
    {
        var records = new Dictionary<string, int>
        {
            { "alpha", 1 },
            { "beta", 2 },
            { "gamma", 3 }
        };

        return records[city];
    }
}

public class SingletonRecordFinder
{
    public int GetTotalPopulation(IEnumerable<string> names)
    {
        var result = 0;
        foreach (var city in names)
        {
            result += SingletonDatabase.Instance.GetPopulation(city);
        }
        return result;
    }
}

public class ConfigurableRecordFinder
{
    private IDatabase database;

    public ConfigurableRecordFinder(IDatabase database)
    {
        this.database = database ?? throw new ArgumentNullException(paramName: nameof(database));
    }

    public int GetTotalPopulation(IEnumerable<string> names)
    {
        var result = 0;
        foreach (var city in names)
        {
            result += database.GetPopulation(city);
        }
        return result;
    }
}

// Project has more than one entry issue:
// Occurred after adding NuGet package Microsoft.NET.Test.Sdk
// https://stackoverflow.com/questions/11747761/i-added-a-new-class-to-my-project-and-got-an-error-saying-program-main-has-mo
// To set the /main compiler option, just right click on the project node in Solution Explorer,
// select Properties, and in the Application section select the "Startup object" in the dropdown.
// To run tests: AutoGeneratedProgram
[TestFixture]
public class SingletonTests
{
    [Test]
    public void IsSingleton()
    {
        var db = SingletonDatabase.Instance;
        var db2 = SingletonDatabase.Instance;

        Assert.That(db, Is.SameAs(db2)); // reference to the same object
    }

    // Relying on a live database in testing is a bad idea!
    // - Costly to instantiate
    // - What if values change or get removed?
    // We want to mock the database, but hardcoded singleton db instance won't allow it
    [Test]
    public void GetTotalPopulation()
    {
        var recordFinder = new SingletonRecordFinder();
        var cities = new string[] { "Tokyo", "New York" };
        var totalPopulation = recordFinder.GetTotalPopulation(cities);

        Assert.AreEqual(33200000 + 17800000, totalPopulation);
    }

    [Test]
    public void GetTotalPopulationConfigurable()
    {
        var db = new DummyDatabase();
        var recordFinder = new ConfigurableRecordFinder(db);
        var cities = new string[] { "alpha", "beta" };
        var totalPopulation = recordFinder.GetTotalPopulation(cities);

        Assert.That(totalPopulation, Is.EqualTo(3));
    }

    [Test]
    public void GetTotalPopulationDependencyInjectionWithAutofac()
    {
        var cb = new ContainerBuilder();
        cb.RegisterType<OrdinaryDatabase>()
            .As<IDatabase>()
            .SingleInstance();

        cb.RegisterType<ConfigurableRecordFinder>();

        using (var c = cb.Build())
        {
            var recordFinder = c.Resolve<ConfigurableRecordFinder>();

            var cities = new string[] { "Tokyo", "New York" };
            var totalPopulation = recordFinder.GetTotalPopulation(cities);

            Assert.AreEqual(33200000 + 17800000, totalPopulation);
        }
    }

    [Test]
    public void GetTotalPopulationDependencyInjectionWithAutofac2()
    {
        var cb = new ContainerBuilder();
        cb.RegisterType<DummyDatabase>()
            .As<IDatabase>()
            .SingleInstance();

        cb.RegisterType<ConfigurableRecordFinder>();

        using (var c = cb.Build())
        {
            var recordFinder = c.Resolve<ConfigurableRecordFinder>();

            var cities = new string[] { "alpha", "beta" };
            var totalPopulation = recordFinder.GetTotalPopulation(cities);

            Assert.That(totalPopulation, Is.EqualTo(3));
        }
    }
}

public class Demo
{
    static void Main()
    {
        var db = SingletonDatabase.Instance;

        // works just fine while you're working with a real database.
        var city = "Tokyo";
        Console.WriteLine($"{city} has population {db.GetPopulation(city)}");
    }
}
